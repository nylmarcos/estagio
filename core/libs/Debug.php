<?php/* * Copyright (c) 2011-2012, Valdirene da Cruz Neves Júnior <linkinsystem666@gmail.com> * All rights reserved. *//** * Classe de depuração das instruções SQL geradas pela classe DatabaseQuery * @author	Valdirene da Cruz Neves Júnior <linkinsystem666@gmail.com> * @version 1.4 *  */class Debug {	/**	 * Guarda as linhas de depuração	 * @var	array	 */	private static $debugs = array();		/**	 * Adiciona uma linha de depuração	 * @param	string	$string		valor da ser impresso	 * @return	void	 */	public static function add($string)	{		self::$debugs[] = $string;	}		/**	 * Adiciona uma linha de depuração de uma instrução SQL	 * @param	string	$sql		instrução SQL	 * @param	array	$values		valores da instrução SQL	 * @return	void	 */	public static function addSql($sql, $values = array())	{		self::$debugs[] = self::bindValues($sql, $values);	}		/**	 * Substitui as "?" (interrogações) pelos valores	 * @param	string	$sql		instrução SQL	 * @param	array	$values		valores da instruções SQL	 * @return	string				retorna a instrução com os valores substituidos	 */	private static function bindValues($sql, $values)	{		$parts = explode('?', trim($sql));		$sql = '';		for($i = 0; $i < count($parts); $i++)		{			if(isset($parts[$i]) && isset($values[$i]))				$sql .= $parts[$i];			if(isset($values[$i]))				$sql .= self::sanitize($values[$i]);		}		return $sql;	}		/**	 * Normaliza um valor de acordo com o SQL	 * @param	mixed	$value	o valor a ser normalizado	 * @return	mixed			retorna o valor normalizado	 */	private static function sanitize($value)	{		if(is_int($value))			return (int) $value + '0';		if(is_double($value) || is_float($value))			return (double) $value + '0';		if(is_bool($value))			return $value ? '1' : '0';		if(is_string($value) && $value != 'NULL')			return "'". $value ."'";		if($value == 'NULL')			return 'NULL';		return null;	}		/**	 * Imprime todas as linhas de depuração	 * @return	void	 */	public static function show()	{		if(self::enabled() && !IS_AJAX && !IS_AUTODOT)		{			foreach(self::$debugs as $d)				echo $d . BR . NL;		}	}		/**	 * Retorna todas as linhas de depuraçãob_clean	 * @return	array	retorna a lista com os debugs	 */	public static function all()	{		return self::$debugs;	}		/**	 * Verifica se o usuário está acessando via rede	 * @param	string	$ip	IP do usuário	 * @return	boolean		retorna verdadeiro se o usuário estiver acessando pela rede, no contrário retorna falso	 */	private static function isNetwork($ip)	{		return false;	}		/**	 * Verifica se o debug está habilidade para este usuário	 * @return	boolean		retorna verdadeiro se o debug estiver habilitado	 */	public static function enabled()	{		$config = Config::get('debug');				if($config['query'] !== false && isset($_GET['debug']) && $_GET['debug'] === $config['query'])			return true;		if($config['type'] != 'off')		{			if($config['type'] == 'local' && (IP == '127.0.0.1' || IP == '::1'))				return true;			if($config['type'] == 'all')				return true;			if($config['type'] == 'network' && self::isNetwork(IP))				return true;		}		return false;	}		/**	 * Imprime uma estrutura, usando a função print_r com a tag <pre>, se o debug estiver habilitado	 * @param	mixed	$struct		estrutura a ser impressa	 * @return	void	 */	public static function pre($struct)	{		if(self::enabled())			pre($struct);	}		/**	 * Imprime uma estrutura, usando a função var_dump, se o debug estiver habilitado	 * @param	mixed	$struct		estrutura a ser impressa	 * @return	void	 */	public static function dump($struct)	{		if(self::enabled())			var_dump ($struct);	}}